{"version":3,"file":"static/chunks/705-03d43607784e56a5.js","mappings":"sqBGuLO,SAASA,EAAcC,CAAyB,CAAU,CAc/D,MAAO,CADHC,EADFC,OAAAA,CAMD,CACEC,MAAM,CAACC,SACPC,IAAI,CAAC,MACLC,OAAO,CAAC,aAAc,GAC3B","sources":["webpack://_N_E/./src/core/app/index.ts","webpack://_N_E/./src/core/index.ts","webpack://_N_E/./src/utils/dates.ts","webpack://_N_E/./src/utils/strings.ts","webpack://_N_E/./src/utils/objects.ts","webpack://_N_E/./src/utils/index.ts","webpack://_N_E/<anon>"],"sourcesContent":["export * from './app-reducer';\nexport * from './app-root-state';\nexport * from './app-store';\nexport * from './app-wrapper';\n","export * from './app';\nexport * from './helpers';\nexport * from './types';\n","/** @module strings\n *  @description Strings utilities\n *  @since 2023.02.01, 00:37\n *  @changed 2023.02.02, 08:19\n */\n\nimport * as constantsConfig from '@/config/constants';\nimport { format } from 'date-fns';\n\nexport function formatIsoDateString(dateStr: string, formatStr?: string): string {\n  if (!formatStr) {\n    formatStr = constantsConfig.dateTimeFormat;\n  }\n  // XXX: Is it bug? Eg: '0012-11-16T16:31:15Z'? -> Change it to 20XX. Is it correct?\n  if (dateStr.startsWith('00')) {\n    dateStr = dateStr.replace(/^00/, '20');\n  }\n  const date = new Date(dateStr);\n  return format(date, formatStr);\n}\n","/** @module strings\n *  @description Strings utilities\n *  @since 2023.01.26, 20:43\n *  @changed 2023.02.15, 22:55\n */\n\nimport { AxiosError } from 'axios';\n\nimport { defaultQuote } from '@/config/constants';\n\n/**\n * @param {string} val\n * @return {number}\n */\nexport const toNumber = (val: string): number => {\n  return (val && typeof val !== 'number' && Number(val)) || 0;\n};\n/**\n * @param {string} val\n * @return {String}\n */\nexport const toString = (val: string): string => {\n  return val; // String(val);\n};\n/**\n * @param {string} val\n * @return {boolean}\n */\nexport const toBoolean = (val: string): boolean => {\n  return !!(val && val !== 'false' && val !== '0');\n};\n\nexport const typeTransforms = {\n  toNumber,\n  toString,\n  toBoolean,\n};\ntype TTypeTransformsKeys = keyof typeof typeTransforms;\n\n/** Returns length of common parts of two strings\n * @param {String} a\n * @param {String} b\n * @return {Number}\n */\nexport const getCommonLength = (a: string, b: string): number => {\n  const maxLen = Math.min(a.length, b.length);\n  let commonLen = 0;\n  for (let len = 1; len < maxLen; len++) {\n    const s = a.substring(0, len);\n    if (b.indexOf(s) === 0) {\n      commonLen = len;\n    }\n  }\n  return commonLen;\n};\n\n/** Uppercase first letter of string\n * @param {string} str\n * @return {str}\n */\nexport const ucFirst = (str: string): string => {\n  str = String(str);\n  return str && str.charAt(0).toUpperCase() + str.slice(1); // .toLowerCase();\n};\n\n/** Convert string to desired type\n * @param {string} type\n * @param {string} val\n * @return {*}\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const toType = (type: string, val: string): string | number | boolean => {\n  const methodName = ('to' + ucFirst(type)) as TTypeTransformsKeys;\n  let result: string | number | boolean = val;\n  if (\n    /* typeTransforms.hasOwnProperty(methodName) && */ typeof typeTransforms[methodName] ===\n    'function'\n  ) {\n    result = typeTransforms[methodName](val);\n  }\n  return result;\n};\n\n/**\n * @param {Number} length - Target hex string length\n * @return {String}\n */\nexport const randomHexString = (length: number): string => {\n  let result = '';\n  for (let i = 0; i < length; i++) {\n    result += Math.floor(Math.random() * 0xf).toString(16);\n  }\n  return result;\n};\n\n/** Convert (mostly error responses) html to text\n * @param {String} html\n * @return {String}\n */\nexport const html2string = (html: string): string => {\n  return (\n    html &&\n    html // Process error from (html) response body\n      .replace(/\\s*<style>[\\s\\S]*<\\/style>/gm, '')\n      .replace(/<title>(.+)<\\/title>/gi, '$1:\\n')\n      .replace(/<[^<>]*>/g, ' ')\n      .replace(/\\r/gm, '\\n') // Newlines\n      .replace(/[ \\t]+\\n/gm, '\\n') // Hanged spaces\n      .replace(/\\n[ \\t]+/gm, '\\n') // Hanged spaces\n      .replace(/\\n{3,}/gm, '\\n\\n') // Extra newlines\n      .replace(/\\n(.+):*[ \\t\\n]+\\1\\n/gm, '\\n$1:\\n') // Remove repeating titles\n      .trim()\n  ); // Trim\n};\n\n/* // TODO: Move to react strings helper?\n * export const splitMultiline = (text, opt) => {\n *   opt = opt || {}\n *   const textClassName = opt.textClassName || 'Text'\n *   const lineClassName = opt.lineClassName || 'TextLine'\n *   return text.split('\\n\\n').map((text, n) => {\n *     const lines = text.split('\\n').map((line, n) => {\n *       return React.createElement('div', { key: 'line' + String(n), className: lineClassName }, line)\n *     })\n *     return React.createElement('div', { key: 'text' + String(n), className: textClassName }, lines)\n *   })\n * }\n */\n\nexport function padNumber(num: number | string, size: number): string {\n  return String(num).padStart(size, '0');\n}\n\n/** Make periods for long numbers. Returns string presentation of number.\n * @param {String|Number} num\n * @param {String} [periodChar=' ']\n * @return {String}\n */\nexport function periodizeNumber(num: number | string, periodChar: string): string {\n  periodChar = periodChar || ' ';\n  let numStr = String(num);\n  // If long number...\n  if (numStr.length > 3 && !numStr.match(/\\D/)) {\n    numStr = numStr.replace(/\\B(?=(\\d{3})+(?!\\d))/g, periodChar);\n  }\n  return numStr;\n}\n\n/** humanizeId -- Make human-readable string from id (eg, 'thisId' -> 'This Id')\n * @param {String} id\n * @return {String}\n */\nexport function humanizeId(id: string): string {\n  return ucFirst(String(id)).replace(/\\B([A-Z][a-z]+)/g, ' $1');\n}\n\nexport function safeEscape(\n  str: string | number | boolean,\n  quote?: boolean | string,\n  addQuotes?: boolean,\n): string {\n  // Passed only addQuotes flag\n  if (quote === true && addQuotes == null) {\n    addQuotes = true;\n    quote = undefined;\n  }\n  quote = quote && typeof quote === 'string' ? quote : defaultQuote;\n  const quoteReg = new RegExp(quote, 'g');\n  str = String(str)\n    .replace(/\\\\/g, '\\\\\\\\')\n    .replace(quoteReg, '\\\\' + quote)\n    .replace(/\\n/g, '\\\\n')\n    .replace(/\\r/g, '\\\\r')\n    .replace(/\\t/g, '\\\\t')\n    // .replace(/\\b/g, '\\\\b')\n    .replace(/\\f/g, '\\\\f');\n\n  if (addQuotes === true && quote) {\n    str = quote + str + quote;\n  }\n  return str;\n}\n\nexport function errorToString(error: Error | AxiosError): string {\n  const metaError = error as Error & AxiosError;\n  /* // Error sample (AxiosError):\n   * code: \"ERR_NETWORK\"\n   * message: \"Network Error\"\n   * name: \"AxiosError\"\n   * stack: \"AxiosError: Network Error\\n    at XMLHttpRequest.handleError (webpack-internal:///./node_modules/axios/lib/adapters/xhr.js:168:14)\"\n   */\n  const {\n    // code,\n    // name,\n    // stack\n    message,\n  } = metaError;\n  return [\n    // name,\n    // code,\n    message,\n  ]\n    .filter(Boolean)\n    .join(': ')\n    .replace(/^Error:\\s*/, '');\n}\n\nexport function stringToInt32(string: string): number {\n  let hash = 0;\n  if (string.length == 0) return hash;\n  for (let i = 0; i < string.length; i++) {\n    const char = string.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash;\n  }\n  return hash;\n}\n\nexport function intToHex(number: number): string {\n  if (number < 0) {\n    number = 0xffffffff + number + 1;\n  }\n  return number.toString(16).toUpperCase();\n}\n\nexport function stringToHash(string: string): string {\n  return intToHex(stringToInt32(string)).padStart(8, '0');\n}\n","/** @module objects\n *  @descr Object helpers.\n *  @since 2023.01.26, 20:43\n *  @changed 2023.01.26, 20:43\n */\n\nimport {\n  squareOpen,\n  squareClose,\n  curlyOpen,\n  curlyClose,\n  errRegExp,\n  errDelim,\n  errDelim2,\n  maxShowStringLength,\n} from '@/config/constants';\n\nimport { safeEscape } from './strings';\n\nexport function reverseKeyAndValueReducer(\n  result: Record<string, string>,\n  [key, val]: [string, string],\n): Record<string, string> {\n  return { ...result, [val]: key };\n}\nexport function reverseDataHash(hash: Record<string, string>): Record<string, string> {\n  return Object.entries(hash).reduce(reverseKeyAndValueReducer, {});\n}\n\nexport function isDomElement(obj: HTMLElement): boolean {\n  return (\n    !!obj &&\n    (typeof HTMLElement === 'object'\n      ? obj instanceof HTMLElement // DOM2\n      : typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string')\n  );\n}\n\nexport function isArray(obj: unknown): boolean {\n  return Array.isArray(obj);\n}\n\nexport function arrayIndexOf(arr: string | unknown[], find: unknown): number {\n  if (!(arr instanceof Array) || !arr.length) {\n    return -1;\n  }\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === find) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nexport function asyncPromiseState(promise: Promise<unknown>): Promise<string> {\n  // See also `config.constants:promiseStatusTexts` -- for `vow` module\n  const temp = {};\n  return Promise.race([promise, temp]).then(\n    (value) => (value === temp ? 'PENDING' : 'FULFILLED'),\n    () => 'REJECTED',\n  );\n}\n\n/**\n * @param {} error\n * @return {object}\n */\ninterface ErrorLike {\n  message?: string;\n  errorMessages?: string[];\n  textStatus?: string;\n  error?: SingleError;\n  jqXHR?: XMLHttpRequest;\n  description?: string;\n  url?: string;\n  location?: string;\n  errorText?: string;\n  status?: string;\n  trace?: string[];\n}\ntype SingleError = string | Error | ErrorLike;\ntype PluralErrors = SingleError | SingleError[];\nexport function errorToPlainString(error: undefined | PluralErrors): string {\n  let text = '',\n    plusText,\n    match;\n\n  try {\n    if (\n      typeof error === 'string' &&\n      (match = error.match(/<soap:Text.*?>([\\s\\S]*)\\s*<\\/soap:Text/m)) != null &&\n      match[0]\n    ) {\n      text = '<b>SOAP error:</b> ' + match[1];\n    }\n    // If the error has already been processed or is empty, then we do not show anything\n    else if (!error) {\n      return '';\n    }\n    // If the error is not an object, we show it as a string\n    else if (typeof error !== 'object') {\n      text = String(error);\n    } else if (Array.isArray(error)) {\n      text = error.map(errorToPlainString).join(errDelim);\n    }\n    // Object with an error\n    else if (error instanceof Error) {\n      text = (error.message || String(error)).replace(/^Error:\\s*/, '');\n    } else if (typeof error.message === 'string') {\n      // console.error('errors.errorToPlainString message', { error: error }); // eslint-disable-line no-console\n      text += error.message;\n    } else if (Array.isArray(error.errorMessages)) {\n      // console.error('errors.errorToPlainString errorMessages', { error: error }); // eslint-disable-line no-console\n      text += error.errorMessages\n        .map(function (error: SingleError) {\n          return errorToPlainString(error);\n        })\n        .join(errDelim2);\n    } else if (error.textStatus === 'parsererror') {\n      text = 'Server response processing error';\n      plusText =\n        error.error ||\n        (error.jqXHR &&\n          error.jqXHR.responseText &&\n          (match = error.jqXHR.responseText.match(/<b>(Parse error|Fatal error).*/)) !== null &&\n          match[0]);\n      if (plusText) {\n        if (typeof plusText === 'string' && plusText.length > maxShowStringLength) {\n          plusText = plusText.substring(0, maxShowStringLength - 3) + '...';\n        }\n        text += errDelim + plusText;\n      }\n    } else if (error.jqXHR && !error.error && error.textStatus === 'error') {\n      text = 'Incorrect server response (the server is unavailable)';\n    } else if (error.error === 'jqXHR') {\n      // console.error('errors.errorToPlainString jqXHR', { error: error }); // eslint-disable-line no-console\n      text = error.description || 'AJAX error';\n      const props = {\n          address: error.url || error.location,\n        },\n        propsText = Object.keys(props)\n          .filter((name: string) => !!props[name as keyof typeof props])\n          .map((name) => name + ': ' + props[name as keyof typeof props])\n          .join(', ');\n\n      if (propsText) {\n        text += ' (' + propsText + ')';\n      }\n      return text;\n    }\n    // Chaining errors\n    else if (error.error && typeof error.error === 'object') {\n      text += errorToPlainString(error.error);\n    }\n    // Server exception, like: {error: \"Exception\", errorCode: 0, description: \"Library\\Helper::getJsonResponse: Node error: ...\"}\n    else if (error.error === 'Exception' && error.description) {\n      text += 'Server exception: ' + error.description;\n    } else {\n      text =\n        error.description ||\n        error.message ||\n        error.error ||\n        error.errorText ||\n        error.status ||\n        'Unknown error';\n      if (text === 'canceledByUser') {\n        // TODO?\n        text = 'Canceled by user';\n      }\n      const plus = [];\n      if (error.jqXHR && error.jqXHR.responseText) {\n        plus.push(error.jqXHR.responseText);\n      }\n      if (error.error && typeof error.error === 'object') {\n        plus.push(error.error);\n      }\n      if (Array.isArray(error.trace)) {\n        plus.push('Error catched in: ' + error.trace.join(', '));\n      }\n      if (plus.length) {\n        text +=\n          errDelim2 +\n          plus\n            .map(function (plus) {\n              if (typeof plus === 'object') {\n                plus = errorToPlainString(plus);\n              }\n              if (typeof plus === 'string' && plus.match(/<html/i)) {\n                plus =\n                  'HTML: ' +\n                  plus\n                    .replace(/<(script|link|style)[^<>]*>[\\s\\S]*?<\\/\\1>/gm, '')\n                    .replace(/(\\s*<[^<>]*>\\s*)+/gm, ' ');\n              }\n              if (typeof plus === 'string' && plus.length > maxShowStringLength) {\n                plus = plus.substring(0, maxShowStringLength - 3) + '...';\n              }\n              return plus;\n            })\n            .join(errDelim);\n      }\n    }\n\n    // Strip extra spaces...\n    const result = text\n      .replace(/[ \\t]+\\n/gm, '\\n') // Hanged spaces\n      .replace(/\\n[ \\t]+/gm, '\\n') // Hanged spaces\n      .replace(/\\n{3,}/gm, '\\n\\n') // Extra newlines\n      .trim(); // Trim\n\n    return result;\n  } catch (error) {\n    console.error('errorToPlainString catched error:', { error: error }); // eslint-disable-line no-console\n    debugger; // eslint-disable-line no-debugger\n    // return String(error);\n    throw error;\n  }\n}\n\nexport function safeStringify(\n  this: unknown,\n  obj: unknown,\n  objId?: string,\n  depth?: number,\n  cache?: unknown[],\n  cacheNames?: string[],\n  nice?: boolean | number,\n): string {\n  objId = objId || '@';\n  depth = depth || 0;\n  cache = cache || [];\n  cacheNames = cacheNames || [];\n  try {\n    // Reusable variables...\n    let p, n, res, id, val, itemId;\n    // Nicify params...\n    let niceSpace = ''; // Single indent space\n    let niceBaseSpace = ''; // This depth level indent space\n    if (nice) {\n      niceSpace = ' ';\n      if (typeof nice === 'number') {\n        for (n = 1; n < nice; n++) {\n          niceSpace += ' ';\n        }\n      }\n      for (n = 0; n < depth; n++) {\n        niceBaseSpace += niceSpace;\n      }\n    }\n    const niceDepthSpace = niceBaseSpace + niceSpace; // This depth level indent space\n    const niceNL = nice ? '\\n' : ''; // Newline\n    if (obj == undefined || (typeof obj === 'number' && isNaN(obj))) {\n      // Null-like\n      return 'null'; // Only JSON symbol for undefined or null values\n    } else if (typeof obj === 'function') {\n      p = obj.name\n        ? 'function ' + obj.name\n        : obj.toString\n        ? safeEscape(obj.toString().replace(/[\\n\\r\\t ]+/g, ' '))\n        : 'anonymous function';\n      p = p.replace(/^(function\\s+\\S+)\\(.*$/, '$1');\n      if (p.length > 80) {\n        p = p.substring(0, 80 - 3) + '...';\n      }\n      return '\"[' + p + ']\"';\n    } else if (typeof obj === 'number' || typeof obj === 'boolean') {\n      // Simple type\n      return safeEscape(obj);\n    } else if (typeof obj === 'string' || typeof obj === 'boolean') {\n      // Quotable type\n      return safeEscape(obj, true);\n    } else if (isDomElement(obj as HTMLElement)) {\n      const domObj = obj as HTMLElement;\n      // domNode?\n      let domId = '';\n      if (domObj.nodeType) {\n        domId += '(nodeType:' + domObj.nodeType + ')';\n      }\n      if (domObj.className) {\n        domId += '.' + domObj.className.replace(/ /g, '.');\n      }\n      if (domObj.id) {\n        domId += '#' + domObj.id;\n      }\n      domId = '\"[DomNode: ' + safeEscape(domId) + ']\"';\n      return domId;\n    } else if (\n      typeof XMLHttpRequest === 'object' &&\n      obj instanceof XMLHttpRequest &&\n      (obj as XMLHttpRequest).readyState != null\n    ) {\n      // XHR?\n      // readyState values:\n      // 0 \tUNSENT \tClient has been created. open() not called yet.\n      // 1 \tOPENED \topen() has been called.\n      // 2 \tHEADERS_RECEIVED \tsend() has been called, and headers and status are available.\n      // 3 \tLOADING \tDownloading; responseText holds partial data.\n      // 4 \tDONE \tThe operation is complete.\n      const readyState = (obj as XMLHttpRequest).readyState;\n      let info = 'readyState:' + readyState;\n      if (readyState === 4) {\n        if ((obj as XMLHttpRequest).status) {\n          info += ',status:' + (obj as XMLHttpRequest).status;\n        }\n      }\n      return '\"[XHR ' + safeEscape(info) + ']\"';\n    }\n    // TODO: Event object\n    else if (obj instanceof Error) {\n      // Error?\n      // Using `UTILS.errorToPlainString` (included `errors` module to `UTILS`)\n      let message = errorToPlainString(obj);\n      let stack = String(obj.stack || '').replace(errRegExp, '');\n      // Remove message duplicate from beggining of stack info\n      if (stack.indexOf(message) === 0) {\n        stack = stack.substring(message.length).trim();\n      }\n      if (obj.name && obj.name !== 'Error') {\n        // oxpd-style error\n        message = '[' + obj.name + '] ' + message;\n      }\n      if (stack) {\n        message += '\\n' + stack;\n      }\n      return safeEscape('Error: ' + message, true);\n    } else if ((p = cache.indexOf(obj)) !== -1) {\n      // Cyclic reference?\n      const cacheId = cacheNames[p];\n      return '\"[cyclic: ' + safeEscape(cacheId) + ']\"';\n    } else if (obj instanceof Array /* || typeof obj[Symbol.iterator] === 'function' */) {\n      // Array?\n      cache.push(obj);\n      cacheNames.push(objId);\n      res = squareOpen;\n      for (n = 0; n < obj.length; n++) {\n        itemId = objId + squareOpen + n + squareClose;\n        val = obj[n];\n        if (n) {\n          res += ',';\n        }\n        res +=\n          niceNL + niceDepthSpace + safeStringify(val, itemId, depth + 1, cache, cacheNames, nice);\n      }\n      res += niceNL + niceBaseSpace + squareClose;\n      return res;\n    } else {\n      // Hash object...\n      cache.push(obj);\n      cacheNames.push(objId);\n      res = curlyOpen;\n      // var newObj = Object.keys(obj).reduce(function(newObj, id) {\n      p = Object.keys(obj) as string[];\n      p.sort();\n      for (n = 0; n < p.length; n++) {\n        id = p[n];\n        val = (obj as Record<string, unknown>)[id];\n        itemId = objId + (/\\W/.test(id) ? squareOpen + id + squareClose : '.' + id);\n        if (n) {\n          res += ',';\n        }\n        val = safeStringify(val, itemId, depth + 1, cache, cacheNames, nice);\n        val = safeEscape(id, true) + ':' + val;\n        res += niceNL + niceDepthSpace + val;\n      }\n      res += niceNL + niceBaseSpace + curlyClose;\n      return res;\n    }\n  } catch (error) {\n    console.error(error); // eslint-disable-line no-console\n    debugger; // eslint-disable-line no-debugger\n    throw error;\n  }\n}\n\nexport function niceStringify(data: unknown): string {\n  return safeStringify(data, undefined, undefined, undefined, undefined, true);\n}\n\ninterface DeepData {\n  a: number | { b: number };\n}\n/**\n * getDeepValue -- Fetch value (id may be hierarchial path like `Account.Login`)\n * @param {Object} data -- Data object\n * @param {String} dataId -- Field id (may be hierarchial path like `Account.Login`)\n */\nexport function getDeepValue(data: DeepData | null | undefined, dataId: string): unknown {\n  if (!data) {\n    return undefined;\n  }\n  let value = data;\n  if (typeof value === 'object' && dataId && typeof dataId === 'string') {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    dataId.split('.').forEach((chunkId) => (value = (value as any)[chunkId]));\n  }\n  return value;\n}\n\ninterface ObjectsDiff {\n  added?: string[];\n  removed?: string[];\n  diff?: string[];\n  equals?: string[];\n}\n/** Compare two objects.\n@return { added, removed, diff, [equals] }\n*/\nexport function getObjectsDiff(\n  objOld: { [x: string]: unknown; a?: number; b?: string } | undefined | null,\n  objNew: { [x: string]: unknown; a?: number; b?: string } | undefined | null,\n): ObjectsDiff {\n  if (objNew == undefined || objOld == undefined) {\n    // One of objects is undefined -- they're different.\n    return {};\n  }\n  const keysNew = Object.keys(objNew);\n  const keysOld = Object.keys(objOld);\n  const results: ObjectsDiff = {\n    // added: [],\n    // removed: [],\n    // diff: [],\n    // equals: [],\n  };\n  keysNew.forEach((key) => {\n    if (!keysOld.includes(key)) {\n      (results.added || (results.added = [])).push(key);\n    } else if (objNew[key] !== objOld[key]) {\n      (results.diff || (results.diff = [])).push(key);\n    }\n  });\n  keysOld.forEach((key) => {\n    if (!keysNew.includes(key)) {\n      (results.removed || (results.removed = [])).push(key);\n    }\n  });\n  return results;\n}\n","export * from './dates';\nexport * from './functions';\nexport * from './objects';\nexport * from './promises';\nexport * from './react-types';\nexport * from './strings';\nexport * from './typescript';\n"],"names":["errorToString","error","metaError","message","filter","Boolean","join","replace"],"sourceRoot":""}